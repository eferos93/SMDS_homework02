---
title: "homework02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# LAB

## Exercise 1
Check the biased nature of $s^2_b$ via MC simulation, generating $n=10$ iid values from a normal distribution. Plot also $s^2$ and comment the difference.

## Exercise 2

What happens if a great player decides to join you, now? Try to simulate the data and perform the test again.

```{r}
set.seed(101)

#num of observations
n <- 50
#num of categories
K <- 4
#number of "players"
m <- 6

nullHypo <- c(7/16, 5/16, 3/16, 1/16)

observed <- matrix(0, nrow = m, ncol = n)
for (i in 1:m) {
  observed[i,] <- sample(1:K, n, prob = nullHypo, replace = TRUE)
}

#p-value very high (0.8074)
print( chisq.test( table(observed), p = nullHypo ) )

# New player with better skills join
observed <- rbind(observed, 
                  sample(1:K, n, prob = c(1/16, 3/16, 5/16, 7/16), replace = TRUE) 
                 )

#now the p-value is incredibly low
print(chisq.test( table(observed), p = nullHypo)  )
```
The p-value of the first test is very high thus, if we would set the significance level to 5%, we would not reject $H_0$, while, in the second case, after adding the observations of the good player sampled with a different probability vector (i.e. 1/16, 3/16, 5/16, 7/16) the p-value is lesser than 0.01, indicating a strong evidence against $H_0$. 

## Exercise 3

Sometimes it could be useful to assess the degree of association, or correlation, between paired samples, using the Pearson, the Kendall’s $\tau$ or the Spearman’s $\rho$ correlation coefficient. Regardless of the adopted cofficient, the null hypothesis for a given correlation coefficent $\rho$ is:
$$
H_0:\rho=0.
$$
The test statistic is then defined as
$$
T = r\sqrt{\frac{n-2}{1-r^2}} \underset{H_0}{\sim} t_{n-2}
$$

where $r=Corr(X,Y)$ is the Pearson correlation coefficient. Suppose to have two samples of the same length $x1,…,xn,y1,…,yn$, and to measure the association between them. Once we compute the test statistic $t_{obs}$, we may then compute the $p$-value (here we are evaluating a two sided test) as:
$$
p = 2Pr_{H_0}(T \geq |t_{obs}|)
$$
Consider now some of the most followed Instagram accounts in 2018: for each of the owners, we report also the number of Twitter followers (in milions). Are the Instagram and Twitter account somehow associated? Perform a correlation test, compute the p-value and give an answer. Here is the dataframe.

```{r}
 Owners <- c( "Katy Perry", "Justin Bieber", "Taylor Swift", "Cristiano Ronaldo",
                   "Kim Kardashian", "Ariana Grande", "Selena Gomez", "Demi Lovato")
      Instagram <- c( 69, 98,107, 123, 110, 118, 135, 67)
      Twitter <- c( 109, 106, 86, 72, 59, 57, 56, 56)
      plot( Instagram, Twitter, pch=21, bg=2, xlim=c(60, 150), ylim=c(40, 120) )
      text( Instagram[-6], Twitter[-6]+5, Owners[-6], cex=0.8 )
      text( Instagram[6], Twitter[6]-5, Owners[6], cex=0.8 )
```

## Exercise 4

Compute analitically $J(γ,γ;y),J(γ,β;y),J(β,β;y)$.

## Exercise 5

Produce the contour plot for the quadratic approximation of the log-likelihood, based on the Taylor series:
$$
l(\theta) - l(\hat{\theta}) \approx -\frac{1}{2}(\theta - \hat\theta)^TJ(\hat\theta)(\theta-\hat\theta)
$$
# DAAG

## Exercise 11 cap 3
The following data represent the total number of aberrant crypt foci (abnormal growths in
the colon) observed in seven rats that had been administered a single dose of the carcinogen
azoxymethane and sacrificed after six weeks (thanks to Ranjana Bird, Faculty of Human Ecology,
University of Manitoba for the use of these data):
$$
87 \; 53 \; 72 \; 90 \; 78 \; 85 \; 83
$$
Enter these data and compute their sample mean and variance. Is the Poisson model appropriate
for these data? To investigate how the sample variance and sample mean differ under the Poisson
assumption, repeat the following simulation experiment several times:
```{r}
x <- rpois(7, 78.3)
mean(x); var(x)
```

## Exercise 13 cap 3
A Markov chain for the weather in a particular season of the year has the transition matrix, from one day to the next:
$$
Pb = 
\begin{bmatrix}
  & Sun & Cloud & Rain\\
Sun & 0.6 & 0.2 & 0.2\\
Cloud & 0.2 & 0.4 & 0.4\\
Rain & 0.4 & 0.3 & 0.3
\end{bmatrix}
$$

It can be shown, using linear algebra, that in the long run this Markov chain will visit the states according to the *stationary* distribution:
$$
\begin{matrix}
Sun & Cloud & Rain\\
0.641 & 0.208 & 0.151
\end{matrix}
$$

A result called the *ergodic* theorem allows us to estimate this distribution by simulating the Markov chain for a long enough time.
a. Simulate 1000 values, and calculate the proportion of times the chain visits each of the states. Compare the proportions given by the simulation with the above theoretical proportions.
```{r}
library(dplyr)
library(zoo)
library(lattice)
Markov <- function (N=100, initial.value=1, P) {
  X <- numeric(N)
  X[1] <- initial.value # States {0: 'Sunny', 1: 'Cloudy', 2: 'Rainy'};
  n <- nrow(P)
  for (i in 2:N){
    X[i] <- sample(1:n, size=1, prob=P[X[i-1], ])
  }
  X - 1
}

transitionMatrix <- 
  matrix(data = list(0.6,0.2,0.2,0.2,0.4,0.4,0.4,0.3,0.3),
         nrow = 3, ncol = 3, byrow = TRUE)
print(transitionMatrix)

samples <- Markov(N = 1000, P = transitionMatrix)

print("\nStates  {0: 'Sunny', 1: 'Cloudy', 2: 'Rain'}")
samples %>% 
  table %>% 
  prop.table

#prop <- function(samples, element) {
#  return( length(samples[samples == element]) / length(samples) )
#}
#print(paste("Sun:", prop(samples, 0)))
#samples %>% prop(., 1) %>% paste("Cloud:", .)
#samples %>% prop(., 2) %>% paste("Rain:", .)
```
The empirical proportions with a sample of 1000 elements are not the exact same as the theoretical ones above, but still the order is respected, namely $p(X = 0) > p(X = 1) > p(X = 2)$ and $p(X = 0)$ is significantly higher than the other two.

b. Here is code that calculates rolling averages of the proportions over a number of simulations
and plots the result. It uses the function rollmean() from the zoo package.
```{r}
plotmarkov <-
  function(n=1000000, start=1, window=10000, transition=Pb, npanels=3){
    xc2 <- Markov(n, start, transition)
    mav0 <- rollmean(as.integer(xc2==0), window) #mav0 and mav1 are equal
    mav1 <- rollmean(as.integer(xc2==0), window) #why having two moving averages that are equal ??
    print( Reduce("&&", mav0 == mav1) )
    npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
                  length=npanels+1), include.lowest=TRUE)
    df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
                     gp=npanel)
    print(xyplot(av0+av1 ~ x | gp, data=df, layout=c(1,npanels),
          type="l", par.strip.text=list(cex=0.65),
          scales=list(x=list(relation="free"))))
  }

plotmarkov(transition = transitionMatrix)
```

Try varying the number of simulations and the width of the window. How wide a window
is needed to get a good sense of the stationary distribution? This series settles down rather
quickly to its stationary distribution (it “burns in” quite quickly). A reasonable width of
window is, however, needed to give an accurate indication of the stationary distribution.

## Exercise 6 cap 4
Here we generate random normal numbers with a sequential dependence structure:
```{r}
y1 <- rnorm(51)
y <- y1[-1] + y1[-51]
acf(y1)
# acf is ‘autocorrelation function’
# (see Chapter 9)
acf(y)
```
Repeat this several times. There should be no consistent pattern in the acf plot for different random samples `y1`. There will be a fairly consistent pattern in the `acf` plot for `y`, a result of the correlation that is introduced by adding to each value the next value in the sequence.

## Exercise 7 cap 4

Create a function that does the calculations in the first two lines of the previous exercise. Put the calculation in a loop that repeats 25 times. Calculate the mean and variance for each vector `y` that is returned. Store the 25 means in the vector `av`, and store the 25 variances in
the vector `v`. Calculate the variance of `av`.


# CS exercises

## Exercise 3.3
Rewrite the following, replacing the loop with efficient code:
```{r}

original <-  function(n = 100000){
  z <- rnorm(n)
  zneg <- 0; j <- 1
  for (i in 1:n) {
    if (z[i]<0) {
      zneg[j] <- z[i]
      j <- j + 1
    }
  }
  return(zneg)
}

optimised <- function(n = 100000){
  z <- rnorm(n)
  return( Filter(function(el) el < 0, z) )
}

optimised_v2 <-  function(n = 100000) {
  z <- rnorm(n)
  return( z[z < 0] )
}

print( "Original: " )
system.time(original(10000000))
print( "Optimised: " )
system.time(optimised(10000000))
print("Optimised v2: ")
system.time(optimised_v2(10000000))

```

Confirm that your rewrite is faster but gives the same result (use system.time()).

### Solution
We proceeded with two attemps, one with the function `Filter`, which failed as it resulted in a far worst performance that the original solution.
Our solution is contained in the function `optimised_v2` by using the expression `z[z < 0]` which returns a new array with just the negative element of `z`

## Exercise 3.5

Consider solving the matrix equation $Ax = y$ for $x$ , where $y$ is a known $n$ vector and $A$ is a known $n × n$ matrix. The formal solution to the problem is $x = A^{-1} y$ , but it is possible to solve the equation directly, without actually forming $A^{-1}$ . This question explores this direct solution. Read the help file for `solve` before trying it.
1. First create an $A$ , $x$ and $y$ satisfying $Ax = y$.
```{r}
set.seed(0); n <- 1000
A <- matrix(runif(n*n),n,n); x.true <- runif(n)
y <- A%*%x.true
```
The idea is to experiment with solving $Ax = y$ for $x$ , but with a known
truth to compare the answer to.

2. Using `solve` , form the matrix $A^{−1}$ explicitly and then form $x_1 = A^{−1}y$ . Note how long this takes. Also assess the mean absolute differ-
ence between $x1$ and $x.true$ (the approximate mean absolute ‘error’ in
the solution).

3. Now use solve to directly solve for $x$ without forming $A^-1$ . Note how
long this takes and assess the mean absolute error of the result.

4. What do you conclude?